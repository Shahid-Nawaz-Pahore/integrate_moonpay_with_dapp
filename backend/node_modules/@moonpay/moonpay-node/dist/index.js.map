{"version":3,"sources":["../src/classes/url/url.ts","../../common/src/environment.ts","../../common/src/Logger.ts","../../common/src/react/useHasOverflow.tsx","../../common/src/react/useIsMounted.tsx","../../common/src/react/useRenderCount.ts","../../common/src/react/useScript.ts","../../common/src/uuid.ts","../../core-sdk/src/constants.ts","../../core-sdk/src/widgetUrl.ts","../src/classes/url/errors/generation.ts","../src/classes/url/errors/parsing.ts","../src/logger.ts","../src/index.ts"],"names":["crypto","useRef","useEffect","useState","url","signature","Logger"],"mappings":"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","sourcesContent":["import crypto from 'crypto';\nimport {\n  stringifyQueryParam,\n  getOriginForConfig,\n  getPathnameForConfig as getPathnameForFlow,\n  WidgetFlow,\n} from '@core-sdk';\nimport { getEnvironmentFromApiKey } from '@common';\nimport { MoonPayURLAuth, MoonPayWidgetQueryParams } from '../../types';\nimport { GenerateSignatureOptions } from './types';\nimport { Logger } from '../../logger';\nimport { UrlGenerationFailed, UrlParsingFailed } from './errors';\n\n/**\n * Class for methods relating to MoonPay URLs.\n */\nexport class MoonPayURL {\n  /**\n   * @param secretKey The secret key for the client\n   */\n  constructor(private secretKey: string, private logger: Logger) {}\n\n  /**\n   * Generate and return a signature for a given URL.\n   * @param url The URL for which to generate the signature.\n   * @returns The generated signature.\n   */\n  generateSignature(\n    url: string,\n    { returnFullUrl: returnFullURL }: GenerateSignatureOptions = {\n      returnFullUrl: false,\n    },\n  ): string | null {\n    const constructedURL = this.constructUrl(url);\n    if (!constructedURL) {\n      return null;\n    }\n\n    const signature = this.constructSignature(constructedURL);\n    if (!returnFullURL) {\n      return signature;\n    }\n\n    constructedURL.searchParams.set('signature', signature);\n    return constructedURL.toString();\n  }\n\n  /**\n   * Verify that a signed URL is valid.\n   * @param url The URL to verify.\n   * @returns `true` if the URL is valid, otherwise `false`.\n   */\n  public isSignatureValid(urlString: string): boolean {\n    let url: URL;\n\n    try {\n      url = new URL(urlString);\n    } catch {\n      return false;\n    }\n\n    const apiKeyParam = url.searchParams.get('apiKey');\n\n    if (!apiKeyParam) {\n      return false;\n    }\n\n    const signatureParam = url.searchParams.get('signature');\n\n    if (!signatureParam) {\n      return false;\n    }\n\n    url.searchParams.delete('signature');\n\n    const signature = this.constructSignature(url);\n\n    try {\n      return crypto.timingSafeEqual(\n        Buffer.from(signatureParam, 'base64'),\n        Buffer.from(signature, 'base64'),\n      );\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Generates and returns a signed URL for a given flow and set of parameters.\n   *\n   * @template TFlow - A generic type that extends WidgetFlow.\n   *\n   * @param {Object} config - The config object.\n   * @param {TFlow} config.flow - The flow type.\n   * @param {MoonPayWidgetQueryParams<TFlow>} config.params - The query parameters for the widget.\n   * @param {MoonPayURLAuth} [config.auth] - Optional authentication for the URL.\n   *\n   * @throws {Error} Throws an error if the config is invalid.\n   *\n   * @returns {string} Returns the constructed URL as a string or null if the URL cannot be constructed.\n   *\n   * @example\n   * const url = moonPay.url.generate({\n   *   flow: 'buy',\n   *   params: { apiKey: 'pk_test', ... },\n   * });\n   */\n  generate<TFlow extends WidgetFlow>({\n    flow,\n    params,\n    auth,\n  }: {\n    flow: TFlow;\n    params: MoonPayWidgetQueryParams<TFlow>;\n    auth?: MoonPayURLAuth;\n  }): string {\n    if ('url' in params) {\n      const url = this.constructUrl(params.url);\n\n      url.searchParams.delete('signature');\n\n      const signature = this.constructSignature(url);\n      url.searchParams.set('signature', signature);\n      return url.toString();\n    }\n\n    const environment = getEnvironmentFromApiKey(this.secretKey);\n\n    const origin = getOriginForConfig({\n      environment,\n      flow,\n    });\n\n    const pathname = getPathnameForFlow({ flow });\n\n    if (!pathname || !origin) {\n      const error = new UrlGenerationFailed();\n      this.logger.error(error.message);\n      throw error;\n    }\n\n    const url = this.constructUrl(pathname, origin);\n\n    Object.entries(params).forEach(([key, value]) => {\n      const stringifiedValue = stringifyQueryParam(value);\n\n      if (!stringifiedValue) {\n        return;\n      }\n\n      url.searchParams.append(key, stringifiedValue);\n    });\n\n    const signature = this.constructSignature(url);\n    url.searchParams.append('signature', signature);\n\n    if (auth) {\n      const oneTimeTokenUrl = this.constructUrl(\n        `/oauth/app/${auth.token}`,\n        url.origin,\n      );\n\n      if (!oneTimeTokenUrl) {\n        const error = new UrlGenerationFailed();\n        this.logger.error(error.message);\n        throw error;\n      }\n\n      oneTimeTokenUrl.search = url.search;\n\n      oneTimeTokenUrl.searchParams.append(\n        'redirectTo',\n        `${url.pathname}${url.search}`,\n      );\n      return oneTimeTokenUrl.toString();\n    }\n\n    return url.toString();\n  }\n\n  private constructUrl(path: string, base?: string): URL {\n    try {\n      const constructedUrl = new URL(path, base);\n      return constructedUrl;\n    } catch (e) {\n      const error = new UrlParsingFailed();\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n\n  private constructSignature(url: URL): string {\n    return crypto\n      .createHmac('sha256', this.secretKey)\n      .update(url.search)\n      .digest('base64');\n  }\n}\n","export function getEnvironmentFromApiKey(apiKey: string) {\n  return apiKey.startsWith('pk_live') || apiKey.startsWith('sk_live')\n    ? 'production'\n    : 'sandbox';\n}\n","export interface LoggerLikeInstance {\n  info(...data: any[]): void;\n  warn(...data: any[]): void;\n  error(...data: any[]): void;\n}\n\nexport type WithLogger<T> = T & {\n  logger?: Logger;\n};\n\nconst NOOP = () => undefined;\n\nconst noopLogger: LoggerLikeInstance = {\n  info: NOOP,\n  warn: NOOP,\n  error: NOOP,\n};\n\nexport class Logger {\n  private prefix: string[];\n\n  private logger: LoggerLikeInstance;\n\n  constructor({\n    logger,\n    prefix,\n  }: {\n    logger: LoggerLikeInstance;\n    prefix?: string[];\n  }) {\n    this.logger = logger;\n    this.prefix = prefix ?? ['Logger'];\n  }\n\n  if(condition: boolean) {\n    return condition ? this : new Logger({ logger: noopLogger });\n  }\n\n  info(...data: any[]) {\n    this.logger.info(`[${this.prefix}]`, ...data);\n  }\n\n  warn(...data: any[]) {\n    this.logger.warn(`[${this.prefix}]`, ...data);\n  }\n\n  error(...data: any[]) {\n    this.logger.error(`[${this.prefix}]`, ...data);\n  }\n}\n\nexport default Logger;\n","import { RefObject, useLayoutEffect, useState } from 'react';\n\nexport default function useHasOverflow(\n  ref: RefObject<HTMLDivElement>,\n): boolean {\n  const [hasOverflow, setHasOverflow] = useState(false);\n\n  useLayoutEffect(() => {\n    const { current } = ref;\n\n    if (!current) return;\n\n    const overflow =\n      current.scrollHeight > current.clientHeight ||\n      (!!current.parentElement &&\n        current.parentElement.scrollHeight >\n          current.parentElement.clientHeight);\n\n    setHasOverflow(overflow);\n  }, [ref]);\n\n  return hasOverflow;\n}\n","// Based on (MIT license):\n// https://github.com/hupe1980/react-is-mounted-hook\n\nimport { useRef, useEffect, useCallback } from 'react';\n\nexport default function useIsMounted(): () => boolean {\n  const ref = useRef(false);\n\n  useEffect(() => {\n    ref.current = true;\n    return () => {\n      ref.current = false;\n    };\n  }, []);\n\n  return useCallback(() => ref.current, [ref]);\n}\n","import { useRef } from 'react';\n\n/**\n * Simple hook that logs to console every time function component is called\n * (rendered) with a counter.\n *\n * @param name Name or identifier to log.\n * @param delay Delay after which to log the count and reset it.\n */\nconst useRenderCount = (name: string, delay = 100): void => {\n  const logTimeout = useRef<ReturnType<typeof setTimeout>>();\n  const count = useRef(0);\n  count.current += 1;\n\n  clearTimeout((logTimeout.current as unknown) as number);\n  logTimeout.current = setTimeout(() => {\n    console.log('render', name, count.current);\n    count.current = 0;\n  }, delay);\n};\n\nexport default useRenderCount;\n","/* eslint-disable consistent-return */\nimport { useEffect, useState } from 'react';\n\nexport interface UseScriptProps {\n  url: string;\n  async?: boolean;\n  defer?: boolean;\n  onLoad?: (e: Event) => void;\n  onAlreadyLoaded?: () => void;\n  onError?: (e: ErrorEvent) => void;\n  skip?: boolean;\n  scriptTagAttributes?: Record<string, string>;\n}\n\nexport interface UseScript {\n  loaded: boolean;\n  error: boolean;\n}\n\nconst cachedScripts = new Set();\n\nconst useScript = ({\n  async = true,\n  defer = false,\n  onError,\n  onLoad,\n  onAlreadyLoaded,\n  skip,\n  url,\n  scriptTagAttributes,\n}: UseScriptProps): UseScript => {\n  const [state, setState] = useState({\n    loaded: cachedScripts.has(url),\n    error: false,\n  });\n\n  useEffect(() => {\n    // If skip prop is true, skip loading as well.\n    if (skip) {\n      return;\n    }\n\n    // If the script is already loaded, don't even try to do it.\n    if (state.loaded) {\n      onAlreadyLoaded?.();\n      return;\n    }\n\n    const script = document.createElement('script');\n\n    script.src = url;\n    // See: https://javascript.info/script-async-defer#dynamic-scripts\n    // for info about the default `async` behavior of dynamically added scripts.\n    script.async = async;\n    script.defer = defer;\n\n    if (scriptTagAttributes) {\n      Object.entries(scriptTagAttributes).forEach(([key, value]) => {\n        script.setAttribute(key, value);\n      });\n    }\n\n    const onScriptLoad = (e: Event) => {\n      // Add url to set so we don't load script twice\n      cachedScripts.add(url);\n      setState({\n        loaded: true,\n        error: false,\n      });\n      onLoad?.(e);\n    };\n\n    const onScriptError = (e: ErrorEvent) => {\n      // Remove script from cache so we can retry\n      cachedScripts.delete(url);\n      setState({\n        loaded: true,\n        error: true,\n      });\n      onError?.(e);\n    };\n\n    script.addEventListener('load', onScriptLoad);\n    script.addEventListener('error', onScriptError);\n\n    // Add script to the document (start loading)\n    document.body.appendChild(script);\n\n    return () => {\n      document.body.removeChild(script);\n      script.removeEventListener('load', onScriptLoad);\n      script.removeEventListener('error', onScriptError);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [skip]);\n\n  return {\n    loaded: state.loaded,\n    error: state.error,\n  };\n};\n\nexport default useScript;\n","/* eslint-disable no-bitwise */\n// Copy from rootdir/src/utils/uuid.ts\n\n// Based on the answers from: https://stackoverflow.com/q/105034\n// Specifically: https://stackoverflow.com/a/2117523\nexport const uuidV4: () => string =\n  typeof window.crypto !== 'undefined' &&\n  typeof window.crypto.getRandomValues !== 'undefined'\n    ? () => {\n        // If we have a cryptographically secure PRNG, use that\n        return (([1e7] as any) + -1e3 + -4e3 + -8e3 + -1e11).replace(\n          /[018]/g,\n          (c: number) =>\n            (\n              c ^\n              ((crypto.getRandomValues(new Uint8Array(1))[0] as number) &\n                (15 >> (c / 4)))\n            ).toString(16),\n        );\n      }\n    : () => {\n        // Otherwise, just use Math.random\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n          const r = (Math.random() * 16) | 0;\n          const v = c === 'x' ? r : (r & 0x3) | 0x8;\n          return v.toString(16);\n        });\n      };\n\n// Some API do not like the formal string representation of UUID (https://www.rfc-editor.org/rfc/rfc4122#page-4)\n// replaceAll cannot be used as it is not supported by IE\nexport const uuidV4NoDashes: () => string = () => uuidV4().replace(/-/g, '');\n","import { WidgetEnvironment } from './types/moonpayCoreSdkConfig';\n\nexport const dimensions = {\n  iframe: {\n    recommended: {\n      height: 640,\n      width: 480,\n    },\n    height: 700,\n    width: 768,\n  },\n};\n\nexport const moonpayOrigins: Record<\n  WidgetEnvironment,\n  Record<string, string>\n> = {\n  sandbox: {\n    buy: 'https://buy-sandbox.moonpay.com',\n    sell: 'https://sell-sandbox.moonpay.com',\n  },\n  production: {\n    buy: 'https://buy.moonpay.com',\n    sell: 'https://sell.moonpay.com',\n  },\n};\n","import { moonpayOrigins } from './constants';\nimport { isMoonPayCoreSdkLegacyConfig } from './helpers';\nimport {\n  MoonPayCoreSdkConfig,\n  MoonPayCoreSdkEnvironment,\n  WidgetEnvironment,\n  WidgetFlow,\n} from './types/moonpayCoreSdkConfig';\n\nexport function stringifyQueryParam(value: any): string | null {\n  if (!value) {\n    return null;\n  }\n\n  if (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return `${value}`;\n  }\n\n  if (typeof value === 'object') {\n    return JSON.stringify(value);\n  }\n\n  return null;\n}\n\nexport function getOriginForConfig({\n  environment,\n  flow,\n}: {\n  environment: WidgetEnvironment;\n  flow: WidgetFlow;\n}): string | undefined {\n  switch (flow) {\n    case 'buy':\n    case 'swapsCustomerSetup':\n    case 'swap':\n    case 'nft':\n    case 'claim':\n    case 'topup':\n    case 'transactionTracker':\n    case 'consumerKyc':\n    case 'fiatBalanceDeposit':\n      return moonpayOrigins[environment].buy;\n    case 'sell':\n    case 'withdraw':\n    case 'fiatBalanceWithdraw':\n      return moonpayOrigins[environment].sell;\n    default:\n      throw new Error(`Flow ${flow} is not supported`);\n  }\n}\n\nexport function getPathnameForConfig({\n  flow,\n}: {\n  flow: WidgetFlow;\n}): string | undefined {\n  switch (flow) {\n    case 'buy':\n    case 'sell':\n      return '/';\n    case 'swap':\n      return '/swaps';\n    case 'swapsCustomerSetup':\n      return '/verify/swaps';\n    case 'consumerKyc':\n      return '/consumer/kyc';\n    case 'nft':\n      return '/nft';\n    case 'claim':\n      return '/claim';\n    case 'topup':\n      return '/topup';\n    case 'withdraw':\n      return '/withdraw';\n    case 'transactionTracker':\n      return '/transaction_receipt';\n    case 'fiatBalanceDeposit':\n      return '/balance/deposit';\n    case 'fiatBalanceWithdraw':\n      return '/balance/withdraw';\n    default:\n      throw new Error(`Flow ${flow} is not supported`);\n  }\n}\n\ninterface GenerateWidgetUrlParams<\n  TSdkEnvironment extends MoonPayCoreSdkEnvironment\n> {\n  config: MoonPayCoreSdkConfig;\n  omitSignature?: boolean;\n  sdkEnvironment?: TSdkEnvironment;\n}\n\nexport function generateWidgetUrl<\n  TSdkEnvironment extends MoonPayCoreSdkEnvironment\n>({\n  config,\n  omitSignature = false,\n  sdkEnvironment,\n}: GenerateWidgetUrlParams<TSdkEnvironment>): URL {\n  if (isMoonPayCoreSdkLegacyConfig(config)) {\n    return new URL(config.params.url);\n  }\n\n  const origin =\n    config.baseOrigin ||\n    getOriginForConfig({\n      environment: config.environment,\n      flow: config.flow,\n    });\n  const pathname = getPathnameForConfig({ flow: config.flow });\n\n  if (!pathname || !origin) {\n    throw new Error('Invalid config');\n  }\n\n  const url = new URL(pathname, origin);\n\n  Object.entries(config.params).forEach(([key, value]) => {\n    const encodedValue = stringifyQueryParam(value);\n\n    if (!encodedValue) {\n      return;\n    }\n\n    url.searchParams.append(key, encodedValue);\n  });\n\n  url.searchParams.append('mpSdk', JSON.stringify(sdkEnvironment));\n\n  if (omitSignature) {\n    url.searchParams.delete('signature');\n  }\n\n  if (config.auth) {\n    const oneTimeTokenUrl = new URL(\n      `/oauth/app/${config.auth.token}`,\n      url.origin,\n    );\n\n    oneTimeTokenUrl.search = url.search;\n\n    // In the OAuthApp screen we extract path and query params from redirectTo\n    // `oneTimeTokenUrl.search = url.search` is there for backward compatibility\n    oneTimeTokenUrl.searchParams.append(\n      'redirectTo',\n      `${url.pathname}${url.search}`,\n    );\n    return oneTimeTokenUrl;\n  }\n\n  return url;\n}\n","export class UrlGenerationFailed extends Error {\n  constructor() {\n    super('Failed to generate URL');\n    this.name = 'UrlGenerationFailed';\n  }\n}\n","export class UrlParsingFailed extends Error {\n  constructor() {\n    super('Failed to parse URL');\n    this.name = 'UrlParsingFailed';\n  }\n}\n","import { Logger as BaseLogger } from '@common';\n\nexport class Logger extends BaseLogger {\n  constructor() {\n    super({ logger: console, prefix: ['MoonPay Node SDK'] });\n  }\n}\n","import { MoonPayURL } from './classes/url';\nimport { Logger } from './logger';\nimport { MoonPayOptions } from './types';\n\nexport class MoonPay {\n  url: MoonPayURL;\n\n  constructor(secretKey: string, { debug }: MoonPayOptions = { debug: true }) {\n    const logger = new Logger().if(debug);\n    this.url = new MoonPayURL(secretKey, logger);\n  }\n}\n"]}