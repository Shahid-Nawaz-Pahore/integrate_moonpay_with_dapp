import crypto2 from 'crypto';

// src/classes/url/url.ts

// ../common/src/environment.ts
function getEnvironmentFromApiKey(apiKey) {
  return apiKey.startsWith("pk_live") || apiKey.startsWith("sk_live") ? "production" : "sandbox";
}

// ../common/src/Logger.ts
var NOOP = () => void 0;
var noopLogger = {
  info: NOOP,
  warn: NOOP,
  error: NOOP
};
var Logger = class _Logger {
  prefix;
  logger;
  constructor({
    logger,
    prefix
  }) {
    this.logger = logger;
    this.prefix = prefix ?? ["Logger"];
  }
  if(condition) {
    return condition ? this : new _Logger({ logger: noopLogger });
  }
  info(...data) {
    this.logger.info(`[${this.prefix}]`, ...data);
  }
  warn(...data) {
    this.logger.warn(`[${this.prefix}]`, ...data);
  }
  error(...data) {
    this.logger.error(`[${this.prefix}]`, ...data);
  }
};

// ../core-sdk/src/constants.ts
var moonpayOrigins = {
  sandbox: {
    buy: "https://buy-sandbox.moonpay.com",
    sell: "https://sell-sandbox.moonpay.com"
  },
  production: {
    buy: "https://buy.moonpay.com",
    sell: "https://sell.moonpay.com"
  }
};

// ../core-sdk/src/widgetUrl.ts
function stringifyQueryParam(value) {
  if (!value) {
    return null;
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    return `${value}`;
  }
  if (typeof value === "object") {
    return JSON.stringify(value);
  }
  return null;
}
function getOriginForConfig({
  environment,
  flow
}) {
  switch (flow) {
    case "buy":
    case "swapsCustomerSetup":
    case "swap":
    case "nft":
    case "claim":
    case "topup":
    case "transactionTracker":
    case "consumerKyc":
    case "fiatBalanceDeposit":
      return moonpayOrigins[environment].buy;
    case "sell":
    case "withdraw":
    case "fiatBalanceWithdraw":
      return moonpayOrigins[environment].sell;
    default:
      throw new Error(`Flow ${flow} is not supported`);
  }
}
function getPathnameForConfig({
  flow
}) {
  switch (flow) {
    case "buy":
    case "sell":
      return "/";
    case "swap":
      return "/swaps";
    case "swapsCustomerSetup":
      return "/verify/swaps";
    case "consumerKyc":
      return "/consumer/kyc";
    case "nft":
      return "/nft";
    case "claim":
      return "/claim";
    case "topup":
      return "/topup";
    case "withdraw":
      return "/withdraw";
    case "transactionTracker":
      return "/transaction_receipt";
    case "fiatBalanceDeposit":
      return "/balance/deposit";
    case "fiatBalanceWithdraw":
      return "/balance/withdraw";
    default:
      throw new Error(`Flow ${flow} is not supported`);
  }
}

// src/classes/url/errors/generation.ts
var UrlGenerationFailed = class extends Error {
  constructor() {
    super("Failed to generate URL");
    this.name = "UrlGenerationFailed";
  }
};

// src/classes/url/errors/parsing.ts
var UrlParsingFailed = class extends Error {
  constructor() {
    super("Failed to parse URL");
    this.name = "UrlParsingFailed";
  }
};

// src/classes/url/url.ts
var MoonPayURL = class {
  /**
   * @param secretKey The secret key for the client
   */
  constructor(secretKey, logger) {
    this.secretKey = secretKey;
    this.logger = logger;
  }
  /**
   * Generate and return a signature for a given URL.
   * @param url The URL for which to generate the signature.
   * @returns The generated signature.
   */
  generateSignature(url, { returnFullUrl: returnFullURL } = {
    returnFullUrl: false
  }) {
    const constructedURL = this.constructUrl(url);
    if (!constructedURL) {
      return null;
    }
    const signature = this.constructSignature(constructedURL);
    if (!returnFullURL) {
      return signature;
    }
    constructedURL.searchParams.set("signature", signature);
    return constructedURL.toString();
  }
  /**
   * Verify that a signed URL is valid.
   * @param url The URL to verify.
   * @returns `true` if the URL is valid, otherwise `false`.
   */
  isSignatureValid(urlString) {
    let url;
    try {
      url = new URL(urlString);
    } catch {
      return false;
    }
    const apiKeyParam = url.searchParams.get("apiKey");
    if (!apiKeyParam) {
      return false;
    }
    const signatureParam = url.searchParams.get("signature");
    if (!signatureParam) {
      return false;
    }
    url.searchParams.delete("signature");
    const signature = this.constructSignature(url);
    try {
      return crypto2.timingSafeEqual(
        Buffer.from(signatureParam, "base64"),
        Buffer.from(signature, "base64")
      );
    } catch {
      return false;
    }
  }
  /**
   * Generates and returns a signed URL for a given flow and set of parameters.
   *
   * @template TFlow - A generic type that extends WidgetFlow.
   *
   * @param {Object} config - The config object.
   * @param {TFlow} config.flow - The flow type.
   * @param {MoonPayWidgetQueryParams<TFlow>} config.params - The query parameters for the widget.
   * @param {MoonPayURLAuth} [config.auth] - Optional authentication for the URL.
   *
   * @throws {Error} Throws an error if the config is invalid.
   *
   * @returns {string} Returns the constructed URL as a string or null if the URL cannot be constructed.
   *
   * @example
   * const url = moonPay.url.generate({
   *   flow: 'buy',
   *   params: { apiKey: 'pk_test', ... },
   * });
   */
  generate({
    flow,
    params,
    auth
  }) {
    if ("url" in params) {
      const url2 = this.constructUrl(params.url);
      url2.searchParams.delete("signature");
      const signature2 = this.constructSignature(url2);
      url2.searchParams.set("signature", signature2);
      return url2.toString();
    }
    const environment = getEnvironmentFromApiKey(this.secretKey);
    const origin = getOriginForConfig({
      environment,
      flow
    });
    const pathname = getPathnameForConfig({ flow });
    if (!pathname || !origin) {
      const error = new UrlGenerationFailed();
      this.logger.error(error.message);
      throw error;
    }
    const url = this.constructUrl(pathname, origin);
    Object.entries(params).forEach(([key, value]) => {
      const stringifiedValue = stringifyQueryParam(value);
      if (!stringifiedValue) {
        return;
      }
      url.searchParams.append(key, stringifiedValue);
    });
    const signature = this.constructSignature(url);
    url.searchParams.append("signature", signature);
    if (auth) {
      const oneTimeTokenUrl = this.constructUrl(
        `/oauth/app/${auth.token}`,
        url.origin
      );
      if (!oneTimeTokenUrl) {
        const error = new UrlGenerationFailed();
        this.logger.error(error.message);
        throw error;
      }
      oneTimeTokenUrl.search = url.search;
      oneTimeTokenUrl.searchParams.append(
        "redirectTo",
        `${url.pathname}${url.search}`
      );
      return oneTimeTokenUrl.toString();
    }
    return url.toString();
  }
  constructUrl(path, base) {
    try {
      const constructedUrl = new URL(path, base);
      return constructedUrl;
    } catch (e) {
      const error = new UrlParsingFailed();
      this.logger.error(error.message);
      throw error;
    }
  }
  constructSignature(url) {
    return crypto2.createHmac("sha256", this.secretKey).update(url.search).digest("base64");
  }
};

// src/logger.ts
var Logger2 = class extends Logger {
  constructor() {
    super({ logger: console, prefix: ["MoonPay Node SDK"] });
  }
};

// src/index.ts
var MoonPay = class {
  url;
  constructor(secretKey, { debug } = { debug: true }) {
    const logger = new Logger2().if(debug);
    this.url = new MoonPayURL(secretKey, logger);
  }
};

export { MoonPay };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map